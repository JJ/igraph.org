




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            develop
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<div<body>

    <nav class="pydoctor-navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://igraph.org/python">igraph</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="igraph.html">igraph</a></code>.<code><a href="igraph.community.html">community</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="undocumented">Undocumented</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id42">
  
  <tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_fastgreedy">_community_fastgreedy</a></code></td>
    <td><span>Community structure based on the greedy optimization of modularity.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_infomap">_community_infomap</a></code></td>
    <td><span>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leading_eigenvector_naive">_community_leading_eigenvector_naive</a></code></td>
    <td><span>Naive implementation of Newman's eigenvector community structure detection.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leading_eigenvector">_community_leading_eigenvector</a></code></td>
    <td><span>Newman's leading eigenvector method for detecting community structure.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_label_propagation">_community_label_propagation</a></code></td>
    <td><span>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_multilevel">_community_multilevel</a></code></td>
    <td><span>Community structure based on the multilevel algorithm of Blondel et al.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_optimal_modularity">_community_optimal_modularity</a></code></td>
    <td><span>Calculates the optimal modularity score of the graph and the corresponding community structure.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_edge_betweenness">_community_edge_betweenness</a></code></td>
    <td><span>Community structure based on the betweenness of the edges in the network.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_spinglass">_community_spinglass</a></code></td>
    <td><span>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_walktrap">_community_walktrap</a></code></td>
    <td><span>Community detection algorithm of Latapy &amp; Pons, based on random walks.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_k_core">_k_core</a></code></td>
    <td><span>Returns some k-cores of the graph.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leiden">_community_leiden</a></code></td>
    <td><span>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_modularity">_modularity</a></code></td>
    <td><span>Calculates the modularity score of the graph with respect to a given clustering.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction private">
  
  <a name="igraph.community._community_fastgreedy">
    
  </a>
  <a name="_community_fastgreedy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_fastgreedy</span>(graph, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Community structure based on the greedy optimization of modularity.</p><p>This algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.</p><p>This algorithm is said to run almost in linear time on sparse graphs.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge attribute name or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexDendrogram.html">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_infomap">
    
  </a>
  <a name="_community_infomap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_infomap</span>(graph, edge_weights=None, vertex_weights=None, trials=10):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">edge_weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr><td></td><td class="fieldArg">vertex_weights</td><td>name of an vertex attribute or a list containing vertex weights.</td></tr><tr><td></td><td class="fieldArg">trials</td><td>the number of attempts to partition the network.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object with an extra attribute called <code>codelength</code> that stores the code length determined by the algorithm.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). <a href="http://dx.doi.org/10.1073/pnas.0706851105" target="_top">http://dx.doi.org/10.1073/pnas.0706851105</a>, <a href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a>.</td></tr><tr><td></td><td colspan="2">M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur. Phys. J. Special Topics 178, 13 (2009). <a href="http://dx.doi.org/10.1140/epjst/e2010-01179-1" target="_top">http://dx.doi.org/10.1140/epjst/e2010-01179-1</a>, <a href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_leading_eigenvector_naive">
    
  </a>
  <a name="_community_leading_eigenvector_naive">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leading_eigenvector_naive</span>(graph, clusters=None, return_merges=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Naive implementation of Newman's eigenvector community structure detection.</p><p>This function splits the network into two components according to the leading eigenvector of the modularity matrix and then recursively takes the given number of steps by splitting the communities as individual networks. This is not the correct way, however, see the reference for explanation. Consider using the correct <code>community_leading_eigenvector</code> method instead.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">clusters</td><td>the desired number of communities. If <code>None</code>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td></td><td class="fieldArg">return_merges</td><td>whether the returned object should be a dendrogram instead of a single clustering.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> or <code><a href="igraph.clustering.VertexDendrogram.html">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_leading_eigenvector">
    
  </a>
  <a name="_community_leading_eigenvector">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leading_eigenvector</span>(graph, clusters=None, weights=None, arpack_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Newman's leading eigenvector method for detecting community structure.</p><p>This is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">clusters</td><td>the desired number of communities. If <code>None</code>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_label_propagation">
    
  </a>
  <a name="_community_label_propagation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_label_propagation</span>(graph, weights=None, initial=None, fixed=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</p><p>Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus. Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">initial</td><td>name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to <i class="math">n-1</i> where <i class="math">n</i> is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.</td></tr><tr><td></td><td class="fieldArg">fixed</td><td>a list of booleans for each vertex. <code>True</code> corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. <a href="http://arxiv.org/abs/0709.2938" target="_top">http://arxiv.org/abs/0709.2938</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_multilevel">
    
  </a>
  <a name="_community_multilevel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_multilevel</span>(graph, weights=None, return_levels=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Community structure based on the multilevel algorithm of Blondel et al.</p><p>This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the adjacent edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.</p><p>This algorithm is said to run almost in linear time on sparse graphs.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge attribute name or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">return_levels</td><td>if <code>True</code>, the communities at each level are returned in a list. If <code>False</code>, only the community structure with the best modularity is returned.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> objects, one corresponding to each level (if <code>return_levels</code> is <code>True</code>), or a <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> corresponding to the best modularity.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_optimal_modularity">
    
  </a>
  <a name="_community_optimal_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_optimal_modularity</span>(graph, *args, **kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the optimal modularity score of the graph and the corresponding community structure.</p><p>This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated membership vector and the corresponding modularity in a tuple.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_edge_betweenness">
    
  </a>
  <a name="_community_edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_edge_betweenness</span>(graph, clusters=None, directed=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Community structure based on the betweenness of the edges in the network.</p><p>The idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">clusters</td><td>the number of clusters we would like to see. This practically defines the "level" where we "cut" the dendrogram to get the membership vector of the vertices. If <code>None</code>, the dendrogram is cut at the level which maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the directionality of the edges should be taken into account or not.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a <code><a href="igraph.clustering.VertexDendrogram.html">VertexDendrogram</a></code> object, initally cut at the maximum modularity or at the desired number of clusters.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_spinglass">
    
  </a>
  <a name="_community_spinglass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_spinglass</span>(graph, *args, **kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">args</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">kwds</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">spins</td><td>integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.</td></tr><tr><td></td><td class="fieldArg">parupdate</td><td>whether to update the spins of the vertices in parallel (synchronously) or not</td></tr><tr><td></td><td class="fieldArg">start_temp</td><td>the starting temperature</td></tr><tr><td></td><td class="fieldArg">stop_temp</td><td>the stop temperature</td></tr><tr><td></td><td class="fieldArg">cool_fact</td><td>cooling factor for the simulated annealing</td></tr><tr><td></td><td class="fieldArg">update_rule</td><td>specifies the null model of the simulation. Possible values are <code>"config"</code> (a random graph with the same vertex degrees as the input graph) or <code>"simple"</code> (a random graph with the same number of edges)</td></tr><tr><td></td><td class="fieldArg">gamma</td><td>the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.</td></tr><tr><td></td><td class="fieldArg">implementation</td><td>currently igraph contains two implementations of the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting <code>implementation</code> to <code>"neg"</code></td></tr><tr><td></td><td class="fieldArg">lambda_</td><td>the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). <a href="http://arxiv.org/abs/cond-mat/0603718" target="_top">http://arxiv.org/abs/cond-mat/0603718</a>.</td></tr><tr><td></td><td colspan="2">Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). <a href="http://arxiv.org/abs/0811.2329" target="_top">http://arxiv.org/abs/0811.2329</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_walktrap">
    
  </a>
  <a name="_community_walktrap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_walktrap</span>(graph, weights=None, steps=4):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Community detection algorithm of Latapy &amp; Pons, based on random walks.</p><p>The basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">steps</td><td>length of random walks to perform</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a <code><a href="igraph.clustering.VertexDendrogram.html">VertexDendrogram</a></code> object, initially cut at the maximum modularity.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, <a href="http://arxiv.org/abs/physics/0512106" target="_top">http://arxiv.org/abs/physics/0512106</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._k_core">
    
  </a>
  <a name="_k_core">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_k_core</span>(graph, *args):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns some k-cores of the graph.</p><p>The method accepts an arbitrary number of arguments representing the desired indices of the <i class="math">k</i>-cores to be returned. The arguments can also be lists or tuples. The result is a single <code><a href="igraph.Graph.html">Graph</a></code> object if an only integer argument was given, otherwise the result is a list of <code><a href="igraph.Graph.html">Graph</a></code> objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all <i class="math">k</i>-cores in increasing order of <i class="math">k</i>.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._community_leiden">
    
  </a>
  <a name="_community_leiden">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leiden</span>(graph, objective_function='CPM', weights=None, resolution_parameter=1.0, beta=0.01, initial_membership=None, n_iterations=2, node_weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">objective_function</td><td>whether to use the Constant Potts Model (CPM) or modularity. Must be either <code>"CPM"</code> or <code>"modularity"</code>.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">resolution_parameter</td><td>the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities.</td></tr><tr><td></td><td class="fieldArg">beta</td><td>parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.</td></tr><tr><td></td><td class="fieldArg">initial_membership</td><td>if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.</td></tr><tr><td></td><td class="fieldArg">n_iterations</td><td>the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).</td></tr><tr><td></td><td class="fieldArg">node_weights</td><td>the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.community._modularity">
    
  </a>
  <a name="_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_modularity</span>(self, membership, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the modularity score of the graph with respect to a given clustering.</p><p>The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as <i class="math">Q=1/(2m)*sum(Aij-ki*kj/(2m)delta(ci,cj),i,j)</i>. <i class="math">m</i> is the number of edges, <i class="math">Aij</i> is the element of the <i class="math">A</i> adjacency matrix in row <i class="math">i</i> and column <i class="math">j</i>, <i class="math">ki</i> is the degree of node <i class="math">i</i>, <i class="math">kj</i> is the degree of node <i class="math">j</i>, and <i class="math">Ci</i> and <code>cj</code> are the types of the two vertices (<i class="math">i</i> and <i class="math">j</i>). <i class="math">delta(x,y)</i> is one iff <i class="math">x=y</i>, 0 otherwise.</p><p>If edge weights are given, the definition of modularity is modified as follows: <i class="math">Aij</i> becomes the weight of the corresponding edge, <i class="math">ki</i> is the total weight of edges adjacent to vertex <i class="math">i</i>, <i class="math">kj</i> is the total weight of edges adjacent to vertex <i class="math">j</i> and <i class="math">m</i> is the total edge weight in the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">membership</td><td>a membership list or a <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object</td></tr><tr><td></td><td class="fieldArg">weights</td><td>optional edge weights or <code>None</code> if all edges are weighed equally. Attribute names are also allowed.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the modularity score</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.</td></tr></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://igraph.org/python">igraph</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

</div>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	  &copy; 2003 &ndash; 2022 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'api/');
    </script>





    
  </body>
</html>
