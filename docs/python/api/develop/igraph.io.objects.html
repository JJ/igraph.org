




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon.ico" type="image/png" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            develop
          </a>
          <div class="dropdown-menu">
            <a class="dropdown-item" href="/python/api/latest/">latest</a>
            
            <a class="dropdown-item" href="/python/api/develop/">develop</a>
            
            <a class="dropdown-item" href="/python/api/master/">master</a>
            
            <a class="dropdown-item" href="/python/api/0.9.6/">0.9.6</a>
            
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<div<body>

    <nav class="pydoctor-navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://igraph.org/python">python-igraph</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="igraph.html">igraph</a></code>.<code><a href="igraph.io.html">io</a></code>.<code><a href="igraph.io.objects.html">objects</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="undocumented">Undocumented</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id236">
  
  <tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dict_list">_construct_graph_from_dict_list</a></code></td>
    <td><span>Constructs a graph from a list-of-dictionaries representation.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_tuple_list">_construct_graph_from_tuple_list</a></code></td>
    <td><span>Constructs a graph from a list-of-tuples representation.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_list_dict">_construct_graph_from_list_dict</a></code></td>
    <td><span>Constructs a graph from a dict-of-lists representation.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dict_dict">_construct_graph_from_dict_dict</a></code></td>
    <td><span>Constructs a graph from a dict-of-dicts representation.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dataframe">_construct_graph_from_dataframe</a></code></td>
    <td><span>Generates a graph from one or two dataframes.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_dict_list">_export_graph_to_dict_list</a></code></td>
    <td><span>Export graph as two lists of dictionaries, for vertices and edges.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_tuple_list">_export_graph_to_tuple_list</a></code></td>
    <td><span>Export graph to a list of edge tuples</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_list_dict">_export_graph_to_list_dict</a></code></td>
    <td><span>Export graph to a dictionary of lists (or other sequences).</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_dict_dict">_export_graph_to_dict_dict</a></code></td>
    <td><span>Export graph to dictionary of dicts of edge attributes</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_vertex_dataframe">_export_vertex_dataframe</a></code></td>
    <td><span>Export vertices with attributes to pandas.DataFrame</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_edge_dataframe">_export_edge_dataframe</a></code></td>
    <td><span>Export edges with attributes to pandas.DataFrame</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction private">
  
  <a name="igraph.io.objects._construct_graph_from_dict_list">
    
  </a>
  <a name="_construct_graph_from_dict_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dict_list</span>(cls, vertices, edges, directed=False, vertex_name_attr='name', edge_foreign_keys=('source', 'target'), iterative=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Constructs a graph from a list-of-dictionaries representation.</p><p>This function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the list of dictionaries for the vertices or <code>None</code> if there are no special attributes assigned to vertices and we should simply use the edge list of dicts to infer vertex names.</td></tr><tr><td></td><td class="fieldArg">edges</td><td>the list of dictionaries for the edges. Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the constructed graph will be directed</td></tr><tr><td></td><td class="fieldArg">vertex_name_attr</td><td>the name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if <code>vertices</code> is <code>None</code>.</td></tr><tr><td></td><td class="fieldArg">edge_foreign_keys</td><td>tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.</td></tr><tr><td></td><td class="fieldArg">iterative</td><td>whether to add the edges to the graph one by one, iteratively, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the graph that was constructed<p>Example:</p><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>vertices = [{<span class="py-string">'name'</span>: <span class="py-string">'apple'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'pear'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'peach'</span>}]
<span class="py-prompt">&gt;&gt;&gt; </span>edges = [{<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'pear'</span>, <span class="py-string">'weight'</span>: 1.2},
<span class="py-more">... </span>         {<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'peach'</span>, <span class="py-string">'weight'</span>: 0.9}]
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.DictList(vertices, edges)</pre><p>The graph has three vertices with names and two edges with weights.</p></td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._construct_graph_from_tuple_list">
    
  </a>
  <a name="_construct_graph_from_tuple_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_tuple_list</span>(cls, edges, directed=False, vertex_name_attr='name', edge_attrs=None, weights=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Constructs a graph from a list-of-tuples representation.</p><p>This representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the <code>edge_attrs</code> list. The names of the vertices will be stored in the vertex attribute given by <code>vertex_name_attr</code>.</p><p>The default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting <code>edge_attrs</code> to <code>"weight"</code> or <code>["weight"]</code>. If you have even more edge attributes, add them to the end of each item in the <code>edges</code> list and also specify the corresponding edge attribute names in <code>edge_attrs</code> as a list.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>the data source for the edges. This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the <code>name</code> vertex attribute (or another vertex attribute if <code>vertex_name_attr</code> is specified), even if all the vertex names in the list are in fact numbers.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the constructed graph will be directed</td></tr><tr><td></td><td class="fieldArg">vertex_name_attr</td><td>the name of the vertex attribute that will contain the vertex names.</td></tr><tr><td></td><td class="fieldArg">edge_attrs</td><td>the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If <code>None</code> or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>alternative way to specify that the graph is weighted. If you set <code>weights</code> to <code>true</code> and <code>edge_attrs</code> is not given, it will be assumed that <code>edge_attrs</code> is <code>["weight"]</code> and igraph will parse the third element from each item into an edge weight. If you set <code>weights</code> to a string, it will be assumed that <code>edge_attrs</code> contains that string only, and igraph will store the edge weights in that attribute.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the graph that was constructed</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._construct_graph_from_list_dict">
    
  </a>
  <a name="_construct_graph_from_list_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_list_dict</span>(cls, edges, directed=False, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._construct_graph_from_dict_dict">
    
  </a>
  <a name="_construct_graph_from_dict_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dict_dict</span>(cls, edges, directed=False, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._construct_graph_from_dataframe">
    
  </a>
  <a name="_construct_graph_from_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dataframe</span>(cls, edges, directed=True, vertices=None, use_vids=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_graph_to_dict_list">
    
  </a>
  <a name="_export_graph_to_dict_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_dict_list</span>(graph, use_vids=True, skip_none=False, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_graph_to_tuple_list">
    
  </a>
  <a name="_export_graph_to_tuple_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_tuple_list</span>(graph, use_vids=True, edge_attrs=None, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Export graph to a list of edge tuples</p><p>This function is the reverse of Graph.TupleList.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">graph</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">use_vids</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">edge_attrs</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">vertex_name_attr</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">use_vids (bool)</td><td>whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td></td><td class="fieldArg">edge_attrs (str or list of str)</td><td>list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of tuples, each representing an edge of the graph.<p>Example:</p><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"apple"</span>, <span class="py-string">"pear"</span>, <span class="py-string">"peach"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"name"</span>] = [<span class="py-string">"first_edge"</span>, <span class="py-string">"second"</span>, <span class="py-string">"third"</span>]</pre><p># Get name of the edge &gt;&gt;&gt; g.to_tuple_list(edge_attrs=["name"]) [(0, 1, "first_edge"), (0, 2, "second"), (1, 2, "third")]</p><p># Use vertex names, no edge attributes &gt;&gt;&gt; g.to_tuple_list(use_vids=False) [("apple", "pear"), ("apple", "peach"), ("pear", "peach")]</p></td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: vertex_name_attr</td><td class="fieldArg">(str)</td><td>only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_graph_to_list_dict">
    
  </a>
  <a name="_export_graph_to_list_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_list_dict</span>(graph, use_vids=True, sequence_constructor=list, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_graph_to_dict_dict">
    
  </a>
  <a name="_export_graph_to_dict_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_dict_dict</span>(graph, use_vids=True, edge_attrs=None, skip_none=False, vertex_name_attr='name'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_vertex_dataframe">
    
  </a>
  <a name="_export_vertex_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_vertex_dataframe</span>(graph):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Export vertices with attributes to pandas.DataFrame</p><p>If you want to use vertex names as index, you can do:</p><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  <a name="igraph.io.objects._export_edge_dataframe">
    
  </a>
  <a name="_export_edge_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_edge_dataframe</span>(graph):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Export edges with attributes to pandas.DataFrame</p><p>If you want to use source and target vertex IDs as index, you can do:</p><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index([<span class="py-string">'source'</span>, <span class="py-string">'target'</span>], inplace=<span class="py-builtin">True</span>)</pre><p>The index will be a pandas.MultiIndex. You can use the `drop=False` option to keep the `source` and `target` columns.</p><p>If you want to use vertex names in the source and target columns:</p><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'source'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'target'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)  <span class="py-comment"># Optional</span></pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names "source" and "target". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns.</td></tr></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://igraph.org/python">python-igraph</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2 at 2021-10-09 17:41:48.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

</div>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
      &copy; 2003 &ndash; 2020 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>

    
  </body>
</html>
