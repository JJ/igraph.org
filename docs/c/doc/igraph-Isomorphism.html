









<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="/img/igraph4.png" type="image/x-icon" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/manual.css" rel="stylesheet">
  </head>

  <body class="cc">
  <div id="wrap">

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle"
                  data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">
            <img src="/img/igraph4.svg" width=35> igraph
          </a>
        </div>
        <div class="navbar-collapse collapse">
	  
	  <ul class="nav navbar-nav">
	    <li><a href="/c">| igraph library</a></li>
	  </ul>
	  
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown"
		 role="button" aria-expanded="false">Products
		<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
		<li>
		  <a href="/r"><i class="icon-fixed-width icon-rlogo"></i>
		    igraph R package</a></li>
		<li>
		  <a href="/python"><i class="icon-fixed-width icon-python"></i>
		    python-igraph</a></li>
		<li>
		  <a href="http://szhorvat.net/mathematica/IGraphM"><i class="icon-fixed-width icon-python"></i>
		    IGraph/M</a></li>
		<li>
		  <a href="/c"><i class="icon-fixed-width icon-c"></i>
		    igraph C library</a></li>
		<li class="divider"></li>
		<li>
		  <a href="https://github.com/igraph/igraphdata">
		    <i class="icon-fixed-width icon-rlogo"></i>
		    igraphdata R package <i class="fa fa-github"></i></a></li>
              </ul>
            </li>
            <li>
              <a href="/news.html"><i class="icon-rss"></i>
		News</a></li>
	    <li><a href="https://github.com/igraph">
	      <i class="icon-github"></i> On github</a></li>
          </ul>
          <!-- <form class="navbar-form navbar-right"> -->
          <!--   <div class="form-group"> -->
          <!--     <input type="text" placeholder="Search docs" -->
	  <!-- 	     class="form-control" size="15"> -->
          <!--   </div> -->
          <!--   <button type="submit" class="btn btn-success"> -->
          <!--     <span class="glyphicon glyphicon-search"></span></button> -->
          <!-- </form> -->
        </div><!--/.navbar-collapse -->
      </div>
    </div>
    
    
    
    <div class="bs-header-outer"><div class="bs-header">
      <div class="container">
        <h1>igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>        
      </div>
    </div></div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-9 col-md-offset-1">
  <div class="bs-docs-section">

    
<div class="navigation-header" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-default" href="igraph-Cliques.html"><i class="icon-chevron-left"></i></a><a accesskey="h" class="btn btn-default" href="index.html"><i class="icon-home"></i></a><a accesskey="n" class="btn btn-default" href="igraph-Motifs.html"><i class="icon-chevron-right"></i></a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Isomorphism"></a>Chapter 16. Graph Isomorphism</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#idm231968334752">1. The simple interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#idm231946230608">2. The BLISS algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#idm231966959568">3. The VF2 algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#idm231945880240">4. The LAD algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#idm231944291888">5. Functions for graphs with 3 or 4 vertices</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231968334752"></a>1. The simple interface</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_permute_vertices">1.1. <code class="function">igraph_permute_vertices</code> — Permute the vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic">1.2. <code class="function">igraph_isomorphic</code> —  Decides whether two graphs are isomorphic</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic">1.3. <code class="function">igraph_subisomorphic</code> — Decide subgraph isomorphism</a></span></dt>
</dl></div>
<p>igraph provides four set of functions to deal with graph
isomorphism problems.</p>
<p>The <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.2. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic" title="1.3. igraph_subisomorphic — Decide subgraph isomorphism"><code class="function">igraph_subisomorphic()</code></a>
functions make up the first set (in addition with the <a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="1.1. igraph_permute_vertices — Permute the vertices"><code class="function">igraph_permute_vertices()</code></a> function). These functions choose the
algorithm which is best for the supplied input graph. (The choice is
not very sophisticated though, see their documentation for
details.)</p>
<p>The VF2 graph (and subgraph) isomorphism algorithm is implemented in
igraph, these functions are the second set. See <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2"><code class="function">igraph_isomorphic_vf2()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for
starters.</p>
<p>Functions for the BLISS algorithm constitute the third set, 
see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS"><code class="function">igraph_isomorphic_bliss()</code></a>. This implementation only works
for undirected graphs.</p>
<p>Finally, the isomorphism classes of all graphs with three and
four vertices are precomputed and stored in igraph, so for these
small graphs there is a very simple fast way to decide isomorphism.
See <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_34" title="5.1. igraph_isomorphic_34 — Graph isomorphism for 3-4 vertices"><code class="function">igraph_isomorphic_34()</code></a>.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_permute_vertices"></a>1.1. <code class="function">igraph_permute_vertices</code> — Permute the vertices</h3></div></div></div>
<a class="indexterm" name="idm231951620896"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_permute_vertices(const igraph_t *graph, igraph_t *res,
			    const igraph_vector_t *permutation);
</pre></div>
<p>
</p>
<p>



This function creates a new graph from the input graph by permuting
its vertices according to the specified mapping. Call this function
with the output of <a class="link" href="igraph-Isomorphism.html#igraph_canonical_permutation" title="2.3. igraph_canonical_permutation — Canonical permutation using BLISS"><code class="function">igraph_canonical_permutation()</code></a> to create
the canonical form of a graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object. The new graph
   is created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  The permutation to apply. Vertex 0 is mapped to
   the first element of the vector, vertex 1 to the second,
etc. Note that it is not checked that the vector contains every
   element only once, and no range checking is performed either.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in terms of the number of
vertices and edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic"></a>1.2. <code class="function">igraph_isomorphic</code> —  Decides whether two graphs are isomorphic</h3></div></div></div>
<a class="indexterm" name="idm231951274032"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic(const igraph_t *graph1, const igraph_t *graph2,
		      igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



</p>
<p>
From Wikipedia: The graph isomorphism problem or GI problem is the
graph theory problem of determining whether, given two graphs G1
and G2, it is possible to permute (or relabel) the vertices of one
graph so that it is equal to the other. Such a permutation is
called a graph isomorphism.</p>
<p>This function decides which graph isomorphism algorithm to be
used based on the input graphs. Right now it does the following:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
If one graph is directed and the other undirected then an
   error is triggered.

</p></li>
<li class="listitem"><p>
If the two graphs does not have the same number of vertices
   and edges it returns with <code class="constant">FALSE</code>.

</p></li>
<li class="listitem"><p>
Otherwise, if the graphs have three or four vertices then an O(1)
   algorithm is used with precomputed data.

</p></li>
<li class="listitem"><p>
Otherwise, if the graphs are directed then VF2 is used, see
   <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2"><code class="function">igraph_isomorphic_vf2()</code></a>.

</p></li>
<li class="listitem"><p>
Otherwise BLISS is used, see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS"><code class="function">igraph_isomorphic_bliss()</code></a>.

</p></li>
</ol></div>
<p> 
</p>
<p> Please call the VF2 and BLISS functions directly if you need
something more sophisticated, e.g. you need the isomorphic mapping.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, will be set to TRUE (1)
       if the two graphs are isomorphic, and FALSE (0) otherwise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic"></a>1.3. <code class="function">igraph_subisomorphic</code> — Decide subgraph isomorphism</h3></div></div></div>
<a class="indexterm" name="idm231951296880"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic(const igraph_t *graph1, const igraph_t *graph2,
			 igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>graph2</code></em> is isomorphic to a subgraph of <em class="parameter"><code>graph1</code></em>.
Currently this function just calls <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for all graphs.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
  undirected. This is supposed to be the bigger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph2</code></em>, or an error is triggered. This is
  supposed to be the smaller graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential. 
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231946230608"></a>2. The BLISS algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_sh_t">2.1. <code class="function">igraph_bliss_sh_t</code> — Splitting heuristics for BLISS</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_info_t">2.2. <code class="function">igraph_bliss_info_t</code> — Information about a BLISS run</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_canonical_permutation">2.3. <code class="function">igraph_canonical_permutation</code> — Canonical permutation using BLISS</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_bliss">2.4. <code class="function">igraph_isomorphic_bliss</code> — Graph isomorphism via BLISS</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_automorphisms">2.5. <code class="function">igraph_automorphisms</code> — Number of automorphisms using BLISS</a></span></dt>
</dl></div>
<p>
BLISS is a successor of the famous NAUTY algorithm and
implementation. While using the same ideas in general, with better
heuristics and data structure BLISS outperforms NAUTY on most
graphs.
</p>
<p>
BLISS was developed and implemented by Tommi Junttila and Petteri Kaski at 
Helsinki University of Technology, Finland. See Tommi Juntilla's 
homepage at <a class="ulink" href="http://www.tcs.hut.fi/~tjunttil/" target="_top">http://www.tcs.hut.fi/~tjunttil/</a> and the publication at 
<a class="ulink" href="http://www.siam.org/proceedings/alenex/2007/alx07_013junttilat.pdf" target="_top">http://www.siam.org/proceedings/alenex/2007/alx07_013junttilat.pdf</a>
for more information.
</p>
<p>
BLISS version 0.35 is included in igraph.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_sh_t"></a>2.1. <code class="function">igraph_bliss_sh_t</code> — Splitting heuristics for BLISS</h3></div></div></div>
<a class="indexterm" name="idm231951588784"></a><p>
</p>
<pre class="programlisting">
typedef enum { IGRAPH_BLISS_F=0, IGRAPH_BLISS_FL, 
	       IGRAPH_BLISS_FS, IGRAPH_BLISS_FM, 
	       IGRAPH_BLISS_FLM, IGRAPH_BLISS_FSM } igraph_bliss_sh_t;
</pre>
<p>
</p>
<p>


</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_F</code>:</span></p></td>
<td><p>
  First non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FL</code>:</span></p></td>
<td><p>
  First largest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FS</code>:</span></p></td>
<td><p>
  First smallest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FM</code>:</span></p></td>
<td><p>
  First maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FLM</code>:</span></p></td>
<td><p>
  Largest maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FSM</code>:</span></p></td>
<td><p>
  Smallest maximally non-trivially
     connected non-singletion cell.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_info_t"></a>2.2. <code class="function">igraph_bliss_info_t</code> — Information about a BLISS run</h3></div></div></div>
<a class="indexterm" name="idm231972645952"></a><p>
</p>
<pre class="programlisting">
typedef struct igraph_bliss_info_t {
  unsigned long nof_nodes;
  unsigned long nof_leaf_nodes;
  unsigned long nof_bad_nodes;
  unsigned long nof_canupdates;
  unsigned long max_level;
  char *group_size;
} igraph_bliss_info_t;
</pre>
<p>
</p>
<p>
</p>
<p>Some secondary information found by the BLISS algorithm is stored
here. It is useful if you wany to study the internal working of the
algorithm.
</p>
<p><b>Values: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">nof_nodes</code>:</span></p></td>
<td><p>
  The number of nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_leaf_nodes</code>:</span></p></td>
<td><p>
  The number of leaf nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_bad_nodes</code>:</span></p></td>
<td><p>
  Number of bad nodes.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_canupdates</code>:</span></p></td>
<td><p>
  Number of canrep updates.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">max_level</code>:</span></p></td>
<td><p>
  Maximum level.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">group_size</code>:</span></p></td>
<td><p>
  The size of the automorphism group of the graph,
   given as a string. It should be deallocated via
   <code class="function">free()</code> if not needed any more.</p></td>
</tr>
</tbody>
</table></div>
<p>
See <a class="ulink" href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a>
for details about the algorithm and these parameters.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_canonical_permutation"></a>2.3. <code class="function">igraph_canonical_permutation</code> — Canonical permutation using BLISS</h3></div></div></div>
<a class="indexterm" name="idm231951716912"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_canonical_permutation(const igraph_t *graph, igraph_vector_t *labeling,
				 igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
</pre></div>
<p>
</p>
<p>



This function computes the canonical permutation which transforms
the graph into a canonical form by using the BLISS algorithm.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it is treated as undirected and the
   multiple edges are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>labeling</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result is stored here. The
   permutation takes vertex 0 to the first element of the vector,
   vertex 1 to the second, etc. The vector will be resized as
   needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The split heuristics to be used in BLISS. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for BLISS"><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then information on BLISS internals is
   stored here. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_bliss"></a>2.4. <code class="function">igraph_isomorphic_bliss</code> — Graph isomorphism via BLISS</h3></div></div></div>
<a class="indexterm" name="idm231972730672"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_bliss(const igraph_t *graph1, const igraph_t *graph2, 
			    igraph_bool_t *iso, igraph_vector_t *map12, 
			    igraph_vector_t *map21,
			    igraph_bliss_sh_t sh1, igraph_bliss_sh_t sh2,
			    igraph_bliss_info_t *info1, igraph_bliss_info_t *info2);
</pre></div>
<p>
</p>
<p>



This function uses the BLISS graph isomorphism algorithm, a
successor of the famous NAUTY algorithm and implementation. BLISS
is open source and licensed according to the GNU GPL. See 
<a class="ulink" href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a> for
details. Currently the 0.35 version of BLISS is included in igraph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, it is assumed to be
  undirected, directed graphs are treated as undirected too.
  The algorithm eliminates multiple edges from the graph first.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it is assumed to be
  undirected, directed graphs are treated as undirected too.
  The algorithm eliminates multiple edges from the graph first.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  A vector or <code class="constant">NULL</code> pointer. If not <code class="constant">NULL</code> then an
  isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
  If the input graphs are not isomorphic then this vector is
  cleared, i.e. it will have length zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Similar to <em class="parameter"><code>map12</code></em>, but for the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>. 
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh1</code></em>:</span></p></td>
<td><p>
  Splitting heuristics to be used for the first graph. See
  <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for BLISS"><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh2</code></em>:</span></p></td>
<td><p>
  Splitting heuristics to be used for the second
  graph. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for BLISS"><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info1</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, information about the canonization of
   the first input graph is stored here. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>
   for details. Note that if the two graphs have different number
   of vertices or edges, then this is not filled.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info2</code></em>:</span></p></td>
<td><p>
  Same as <em class="parameter"><code>info1</code></em>, but for the second graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, but in practice it is quite fast.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_automorphisms"></a>2.5. <code class="function">igraph_automorphisms</code> — Number of automorphisms using BLISS</h3></div></div></div>
<a class="indexterm" name="idm231944920880"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_automorphisms(const igraph_t *graph,
			 igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
</pre></div>
<p>
</p>
<p>



The number of automorphisms of a graph is computed using BLISS. The
result is returned as part of the <em class="parameter"><code>info</code></em> structure, in tag <code class="constant">group_size</code>. It is returned as a string, as it can be very high even
for relatively small graphs. If the GNU MP library is used then
this number is exact, otherwise a <span class="type">long double</span> is used
and it is only approximate. See also <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it is treated as undirected and the
   multiple edges are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The split heuristics to be used in BLISS. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for BLISS"><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  The result is stored here, in particular in the <code class="constant">group_size</code> tag of <em class="parameter"><code>info</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231966959568"></a>3. The VF2 algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_vf2">3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2">3.2. <code class="function">igraph_count_isomorphisms_vf2</code> — Number of isomorphisms via VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2">3.3. <code class="function">igraph_get_isomorphisms_vf2</code> — Collect the isomorphic mappings</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isohandler_t">3.4. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isocompat_t">3.5. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2">3.6. <code class="function">igraph_isomorphic_function_vf2</code> — The generic VF2 interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_vf2">3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2">3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2">3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> — Return all subgraph isomorphic mappings</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2">3.10. <code class="function">igraph_subisomorphic_function_vf2</code> — Generic VF2 function for subgraph isomorphism problems</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_vf2"></a>3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2</h3></div></div></div>
<a class="indexterm" name="idm231972890000"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2, 
			  const igraph_vector_int_t *vertex_color1,
			  const igraph_vector_int_t *vertex_color2,
			  const igraph_vector_int_t *edge_color1,
			  const igraph_vector_int_t *edge_color2,
			  igraph_bool_t *iso, igraph_vector_t *map12, 
			  igraph_vector_t *map21,
			  igraph_isocompat_t *node_compat_fn,
			  igraph_isocompat_t *edge_compat_fn,
			  void *arg);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function performs the VF2 algorithm via calling <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>.

</p>
<p> Note that this function cannot be used for
deciding subgraph isomorphism, use <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for that.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph. It must have the same directedness
   as <em class="parameter"><code>graph1</code></em>, otherwise an error is reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a logical constant, the result of the
   algorithm will be placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not 
   a NULL pointer then the mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (ie. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not
   a NULL pointer then the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (ie. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2"><code class="function">igraph_count_isomorphisms_vf2()</code></a>, 
<a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2" title="3.3. igraph_get_isomorphisms_vf2 — Collect the isomorphic mappings"><code class="function">igraph_get_isomorphisms_vf2()</code></a>,
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, what did you expect?

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231972702688"></a><p class="title"><b>Example 16.1.  File <code class="code">examples/simple/igraph_isomorphic_vf2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;time.h&gt;

int <span class="strong"><strong>random_permutation</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec) {
  <span class="emphasis"><em>/* We just do size(vec) * 2 swaps */</em></span>
  long int one, two, tmp, i, n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vec);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;2*n; i++) {
    one= (double)<span class="strong"><strong>rand</strong></span>() / RAND_MAX * n;
    two= (double)<span class="strong"><strong>rand</strong></span>() / RAND_MAX * n;
    tmp=one; one=two; two=tmp;
  }
  <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
  
  igraph_t ring1, ring2;
  igraph_vector_int_t color1, color2;
  <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> perm;
  igraph_bool_t iso;
  igraph_integer_t count;
  long int i;

  <span class="strong"><strong>srand</strong></span>(<span class="strong"><strong>time</strong></span>(0));

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>1);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1)-1);
  <span class="strong"><strong>random_permutation</strong></span>(&amp;perm);
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="1.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;ring1, &amp;ring2, &amp;perm);
  
  <span class="emphasis"><em>/* Without colors */</em></span>
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.2. igraph_isomorphic — Decides whether two graphs are isomorphic">igraph_isomorphic</a></strong></span>(&amp;ring1, &amp;ring2, &amp;iso);
  <span class="strong"><strong>if</strong></span> (!iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Without color failed.\n");
    <span class="strong"><strong>return</strong></span> 1;
  }

  <span class="emphasis"><em>/* Without colors, number of isomorphisms */</em></span>
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, 0, 0, &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 200) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count without colors failed, expected %li, got %li.\n",
	    (long int) 200, (long int) count);
    <span class="strong"><strong>return</strong></span> 2;
  }

  <span class="emphasis"><em>/* Everything has the same colors */</em></span>
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (!iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Single color failed.\n");
    <span class="strong"><strong>return</strong></span> 3;
  }
  
  <span class="emphasis"><em>/* Two colors, just counting */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i+=2) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i+1] = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 1;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 100) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected %li, got %li.\n",
	    (long int) 100, (long int) count);
    <span class="strong"><strong>return</strong></span> 4;
  }

  <span class="emphasis"><em>/* Separate colors for each vertex */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i++) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = i;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 1) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with separate colors failed, expected %li, got %li.\n",
	    (long int) 1, (long int) count);
    <span class="strong"><strong>return</strong></span> 5;
  }

  <span class="emphasis"><em>/* Try a negative result */</em></span>
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0); 
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0]=1;
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Negative test failed.\n");
    <span class="strong"><strong>return</strong></span> 6;
  }

  <span class="emphasis"><em>/* Another negative, same color distribution, different topology */</em></span>
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0); 
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0]=1;  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[1]=1;
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[0]=1;  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[2]=1;
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Second negative test failed.\n");
    <span class="strong"><strong>return</strong></span> 7;
  }  
  
  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);

  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
  <span class="emphasis"><em>/* SUBGRAPH ISOMORPHISM                                             */</em></span>
  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring2, 80 , <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);

  <span class="emphasis"><em>/* One color */</em></span>
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, 
				   &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 42) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with one color failed, expected %li, got %li.\n",
	    (long int) 42, (long int) count);
    <span class="strong"><strong>return</strong></span> 31;
  }

  <span class="emphasis"><em>/* Two colors */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i+=2) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i+1] = 1;
  }
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2); i+=2) {  
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i]   = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i+1] = 1;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, 
				   &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 21) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected %li, got %li.\n",
	    (long int) 21, (long int) count);
    <span class="strong"><strong>return</strong></span> 32;
  }

  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
  <span class="emphasis"><em>/* EDGE COLORING, GRAPH ISOMORPHISM                                 */</em></span>
  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1)-1);
  <span class="strong"><strong>random_permutation</strong></span>(&amp;perm);
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="1.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;ring1, &amp;ring2, &amp;perm);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);

  <span class="emphasis"><em>/* Everything has the same color */</em></span>
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1));
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring2));
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (!iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Single edge-color failed.\n");
    <span class="strong"><strong>return</strong></span> 41;
  }

  <span class="emphasis"><em>/* Two colors, just counting */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i+=2) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i+1] = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 1;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 100) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two edge colors failed, expected %li, got %li.\n",
	    (long int) 100, (long int) count);
    <span class="strong"><strong>return</strong></span> 42;
  }

  <span class="emphasis"><em>/* Separate colors for each edge */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i++) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = i;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 1) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with separate edge colors failed, expected %li, got %li.\n",
	    (long int) 1, (long int) count);
    <span class="strong"><strong>return</strong></span> 43;
  }  

  <span class="emphasis"><em>/* Try a negative result */</em></span>
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0); 
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0]=1;
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Negative edge test failed.\n");
    <span class="strong"><strong>return</strong></span> 44;
  }

  <span class="emphasis"><em>/* Another negative, same color distribution, different topology */</em></span>
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
  <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0); 
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0]=1;  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[1]=1;
  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[0]=1;  <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[2]=1;
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (iso) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Second negative edge test failed.\n");
    <span class="strong"><strong>return</strong></span> 45;
  }    

  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
  <span class="emphasis"><em>/* EDGE COLORED SUBGRAPH ISOMORPHISM                                */</em></span>
  <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring2, 80 , <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);

  <span class="emphasis"><em>/* One color */</em></span>
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1));
  <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring2));
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2,
				   &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 42) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with one edge color failed, expected %li, got %li.\n",
	    (long int) 42, (long int) count);
    <span class="strong"><strong>return</strong></span> 51;
  }

  <span class="emphasis"><em>/* Two colors */</em></span>
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1)-1; i+=2) {
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i+1] = 1;
  }
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2)-1; i+=2) {  
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i]   = 0;
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i+1] = 1;
  }
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2,
				   &amp;count, 0, 0, 0);
  <span class="strong"><strong>if</strong></span> (count != 22) {
    <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two edge colors failed, expected %li, got %li.\n",
	    (long int) 22, (long int) count);
    <span class="strong"><strong>return</strong></span> 52;
  }

  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
  <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_isomorphisms_vf2"></a>3.2. <code class="function">igraph_count_isomorphisms_vf2</code> — Number of isomorphisms via VF2</h3></div></div></div>
<a class="indexterm" name="idm231944813504"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_count_isomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2, 
				  const igraph_vector_int_t *vertex_color1,
				  const igraph_vector_int_t *vertex_color2,
				  const igraph_vector_int_t *edge_color1,
				  const igraph_vector_int_t *edge_color2,
				  igraph_integer_t *count,
				  igraph_isocompat_t *node_compat_fn,
				  igraph_isocompat_t *edge_compat_fn,
				  void *arg);
</pre></div>
<p>
</p>
<p>



This function counts the number of isomorphic mappings between two
graphs. It uses the generic <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>
function. 
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Point to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_isomorphisms_vf2"></a>3.3. <code class="function">igraph_get_isomorphisms_vf2</code> — Collect the isomorphic mappings</h3></div></div></div>
<a class="indexterm" name="idm231945592304"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_isomorphisms_vf2(const igraph_t *graph1,
				const igraph_t *graph2,
				const igraph_vector_int_t *vertex_color1,
				const igraph_vector_int_t *vertex_color2,
				const igraph_vector_int_t *edge_color1,
				const igraph_vector_int_t *edge_color2,
				igraph_vector_ptr_t *maps,
				igraph_isocompat_t *node_compat_fn,
				igraph_isocompat_t *edge_compat_fn,
				void *arg);
</pre></div>
<p>
</p>
<p>
 


This function finds all the isomorphic mappings between two
graphs. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>
function. Call the function with the same graph as <em class="parameter"><code>graph1</code></em> and <em class="parameter"><code>graph2</code></em> to get automorphisms.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector. On return it is empty if the input graphs
  are no isomorphic. Otherwise it contains pointers to
  <span class="type">igraph_vector_t</span> objects, each vector is an
  isomorphic mapping of <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>. Please note that
  you need to 1) Destroy the vectors via <a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>, 2) free them via
  <code class="function">free()</code> and then 3) call <a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> on the pointer vector to deallocate all
  memory when <em class="parameter"><code>maps</code></em> is no longer needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isohandler_t"></a>3.4. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</h3></div></div></div>
<a class="indexterm" name="idm231944730608"></a><pre class="programlisting">
typedef igraph_bool_t igraph_isohandler_t(const igraph_vector_t *map12, 
					  const igraph_vector_t *map21, void *arg);
</pre>
<p>
 

See the details at the documentation of <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  The mapping from the first graph to the second.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  The mapping from the second graph to the first, the
  inverse of <em class="parameter"><code>map12</code></em> basically.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  This extra argument was passed to <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a> when it was called.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, whether to continue with the isomorphism search.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isocompat_t"></a>3.5. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</h3></div></div></div>
<a class="indexterm" name="idm231944716368"></a><pre class="programlisting">
typedef igraph_bool_t igraph_isocompat_t(const igraph_t *graph1,
					 const igraph_t *graph2,
					 const igraph_integer_t g1_num,
					 const igraph_integer_t g2_num,
					 void *arg);
</pre>
<p>
 

VF2 (subgraph) isomorphism functions can be restricted by defining 
relations on the vertices and/or edges of the graphs, and then checking 
whether the vertices (edges) match according to these relations. 

</p>
<p>This feature is implemented by two callbacks, one for 
vertices, one for edges. Every time igraph tries to match a vertex (edge) 
of the first (sub)graph to a vertex of the second graph, the vertex 
(edge) compatibility callback is called. The callback returns a 
logical value, giving whether the two vertices match.

</p>
<p>Both callback functions are of type <code class="constant">igraph_isocompat_t</code>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g1_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the first graph. 
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g2_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to pass to the callback functions.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Logical scalar, whether vertex (or edge) <em class="parameter"><code>g1_num</code></em> in <em class="parameter"><code>graph1</code></em> 
   is compatible with vertex (or edge) <em class="parameter"><code>g2_num</code></em> in <em class="parameter"><code>graph2</code></em>.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_function_vf2"></a>3.6. <code class="function">igraph_isomorphic_function_vf2</code> — The generic VF2 interface</h3></div></div></div>
<a class="indexterm" name="idm231944229408"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_function_vf2(const igraph_t *graph1, const igraph_t *graph2, 
				   const igraph_vector_int_t *vertex_color1,
				   const igraph_vector_int_t *vertex_color2,
				   const igraph_vector_int_t *edge_color1,
				   const igraph_vector_int_t *edge_color2,
				   igraph_vector_t *map12,
				   igraph_vector_t *map21,
				   igraph_isohandler_t *isohandler_fn,
				   igraph_isocompat_t *node_compat_fn,
				   igraph_isocompat_t *edge_compat_fn,
				   void *arg);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is an implementation of the VF2 isomorphism algorithm, 
see P. Foggia, C. Sansone, M. Vento, An Improved algorithm for
matching large graphs, Proc. of the 3rd IAPR-TC-15 International
Workshop on Graph-based Representations, Italy, 2001.</p>
<p>For using it you need to define a callback function of type
<a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This function will be called whenever VF2
finds an isomorphism between the two graphs. The mapping between
the two graphs will be also provided to this function. If the
callback returns a nonzero value then the search is continued,
otherwise it stops.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code> and the supplied graphs are isomorphic then the permutation
  taking <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph</code></em> is stored here. If not <code class="constant">NULL</code> and the
  graphs are not isomorphic then a zero-length vector is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  This is the same as <em class="parameter"><code>map12</code></em>, but for the permutation
  taking <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  The callback function to be called if an
  isomorphism is found. See also <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_vf2"></a>3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</h3></div></div></div>
<a class="indexterm" name="idm231945284000"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2, 
			     const igraph_vector_int_t *vertex_color1,
			     const igraph_vector_int_t *vertex_color2,
			     const igraph_vector_int_t *edge_color1,
			     const igraph_vector_int_t *edge_color2,
			     igraph_bool_t *iso, igraph_vector_t *map12, 
			     igraph_vector_t *map21,
			     igraph_isocompat_t *node_compat_fn,
			     igraph_isocompat_t *edge_compat_fn,
			     void *arg);
</pre></div>
<p>
</p>
<p>



Decides whether a subgraph of <em class="parameter"><code>graph1</code></em> is isomorphic to <em class="parameter"><code>graph2</code></em>. It uses <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean. The result of the decision problem
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> 
  and <em class="parameter"><code>edge_compat_fn</code></em>. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_subisomorphisms_vf2"></a>3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</h3></div></div></div>
<a class="indexterm" name="idm231945058032"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_count_subisomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2, 
				     const igraph_vector_int_t *vertex_color1,
				     const igraph_vector_int_t *vertex_color2,
				     const igraph_vector_int_t *edge_color1,
				     const igraph_vector_int_t *edge_color2,
				     igraph_integer_t *count,
				     igraph_isocompat_t *node_compat_fn,
				     igraph_isocompat_t *edge_compat_fn,
				     void *arg);
</pre></div>
<p>
</p>
<p>



Count the number of isomorphisms between subgraphs of <em class="parameter"><code>graph1</code></em> and
<em class="parameter"><code>graph2</code></em>. This function uses <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Pointer to an integer. The number of subgraph
   isomorphisms is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_subisomorphisms_vf2"></a>3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> — Return all subgraph isomorphic mappings</h3></div></div></div>
<a class="indexterm" name="idm231951451744"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_subisomorphisms_vf2(const igraph_t *graph1,
				   const igraph_t *graph2,
				   const igraph_vector_int_t *vertex_color1,
				   const igraph_vector_int_t *vertex_color2,
				   const igraph_vector_int_t *edge_color1,
				   const igraph_vector_int_t *edge_color2,
				   igraph_vector_ptr_t *maps,
				   igraph_isocompat_t *node_compat_fn,
				   igraph_isocompat_t *edge_compat_fn,
				   void *arg);
</pre></div>
<p>
</p>
<p>
 


This function collects all isomorphic mappings of <em class="parameter"><code>graph2</code></em> to a
subgraph of <em class="parameter"><code>graph1</code></em>. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a> function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector. On return it contains pointers to
  <span class="type">igraph_vector_t</span> objects, each vector is an
  isomorphic mapping of <em class="parameter"><code>graph2</code></em> to a subgraph of <em class="parameter"><code>graph1</code></em>. Please note that
  you need to 1) Destroy the vectors via <a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>, 2) free them via
  <code class="function">free()</code> and then 3) call <a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> on the pointer vector to deallocate all
  memory when <em class="parameter"><code>maps</code></em> is no longer needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> 
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_function_vf2"></a>3.10. <code class="function">igraph_subisomorphic_function_vf2</code> — Generic VF2 function for subgraph isomorphism problems</h3></div></div></div>
<a class="indexterm" name="idm231968136240"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_function_vf2(const igraph_t *graph1, 
				      const igraph_t *graph2,
				      const igraph_vector_int_t *vertex_color1,
				      const igraph_vector_int_t *vertex_color2,
				      const igraph_vector_int_t *edge_color1,
				      const igraph_vector_int_t *edge_color2,
				      igraph_vector_t *map12,
				      igraph_vector_t *map21,
				      igraph_isohandler_t *isohandler_fn,
				      igraph_isocompat_t *node_compat_fn,
				      igraph_isocompat_t *edge_compat_fn,
				      void *arg);
</pre></div>
<p>
</p>
<p>



This function is the pair of <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>,
for subgraph isomorphism problems. It searches for subgraphs of <em class="parameter"><code>graph1</code></em> which are isomorphic to <em class="parameter"><code>graph2</code></em>. When it founds an
isomorphic mapping it calls the supplied callback <em class="parameter"><code>isohandler_fn</code></em>.
The mapping (and its inverse) and the additional <em class="parameter"><code>arg</code></em> argument
are supplied to the callback.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not 
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This will be called whenever a subgraph
  isomorphism is found. If the function returns with a non-zero value
  then the search is continued, otherwise it stops and the function
  returns. 
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231945880240"></a>4. The LAD algorithm</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_lad">4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_lad"></a>4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</h3></div></div></div>
<a class="indexterm" name="idm231945878384"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_lad(const igraph_t *pattern, const igraph_t *target, 
			     igraph_vector_ptr_t *domains,
			     igraph_bool_t *iso, igraph_vector_t *map, 
			     igraph_vector_ptr_t *maps, 
			     igraph_bool_t induced, int time_limit);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>pattern</code></em> is isomorphic to a subgraph os <em class="parameter"><code>target</code></em>.
The original LAD implementation by Christine Solnon was used as the 
basis of this code. 

</p>
<p>
See more about at <a class="ulink" href="http://liris.cnrs.fr/csolnon/LAD.html" target="_top">http://liris.cnrs.fr/csolnon/LAD.html</a> and in
Christine Solnon: AllDifferent-based Filtering for Subgraph
Isomorphism. Artificial Intelligence, 174(12-13):850-864, August
2010, Elsevier

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>pattern</code></em>:</span></p></td>
<td><p>
  The smaller graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The bigger graph, it can be directed or undirected. 
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>domains</code></em>:</span></p></td>
<td><p>
  A pointer vector, or a null pointer. If a pointer
   vector, then it must contain pointers to <code class="constant">igraph_vector_t</code>
   objects and the length of the vector must match the number of
   vertices in the <em class="parameter"><code>pattern</code></em> graph. For each vertex, the ids of
   the compatible vertices in the target graph are listed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, or a null pointer. If not a null
   pointer, then the boolean is set to TRUE (1) if a subgraph
   isomorphism is found, and to FALSE (0) otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or a null pointer. If not a null
   pointer and a subgraph isomorphism is found, the matching
   vertices from the target graph are listed here, for each vertex
   (in vertex id order) from the pattern graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector or a null pointer. If not a null
   pointer, then all subgraph isomorphisms are stored in the
   pointer vector, in <code class="constant">igraph_vector_t</code> objects.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>induced</code></em>:</span></p></td>
<td><p>
  Boolean, whether to search for induced matching
   subgraphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>time_limit</code></em>:</span></p></td>
<td><p>
  Processor time limit in seconds. Supply zero
   here for no limit. If the time limit is over, then the function
   signals an error.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for the VF2 algorithm.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231951361824"></a><p class="title"><b>Example 16.2.  File <code class="code">examples/simple/igraph_subisomorphic_lad.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
  igraph_t target, pattern;
  igraph_bool_t iso;
  <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> map;
  igraph_vector_ptr_t maps;
  int i, n;
  int domainsvec[] = { 0, 2, 8, -1,
		       4, 5, 6, 7, -1, 
		       1, 3, 5, 6, 7, 8, -1,
		       0, 2, 8, -1,
		       1, 3, 7, 8, -1, -2 };
  igraph_vector_ptr_t domains;
  <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=0;

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;target, 9, IGRAPH_UNDIRECTED, 
	       0,1,0,4,0,6,
	       1,0,1,4,1,2,
	       2,1,2,3,
	       3,2,3,4,3,5,3,7,3,8,
	       4,0,4,1,4,3,4,5,4,6,
	       5,6,5,4,5,3,5,8,
	       6,0,6,4,6,5,
	       7,3,7,8,
	       8,5,8,3,8,7, 
	       -1);
  <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_simplify" title="14.6. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;target, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;pattern, 5, IGRAPH_UNDIRECTED,
	       0,1,0,4,
	       1,0,1,4,1,2,
	       2,1,2,3,
	       3,2,3,4,
	       4,3,4,1,4,0,
	       -1);
  <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_simplify" title="14.6. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;pattern, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;map, 0);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;maps, 0);
  
  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0, &amp;iso, &amp;map, 
			   &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> 0, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);

  <span class="strong"><strong>if</strong></span> (!iso) { <span class="strong"><strong>return</strong></span> 1; }
  <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
  n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
    <span class="strong"><strong>igraph_vector_print</strong></span>(v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="1. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
  }
 
  <span class="strong"><strong>printf</strong></span>("---------\n");

  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0, &amp;iso, &amp;map, 
			   &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> 1, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);

  <span class="strong"><strong>if</strong></span> (!iso) { <span class="strong"><strong>return</strong></span> 2; }
  <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
  n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
    <span class="strong"><strong>igraph_vector_print</strong></span>(v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="1. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
  }

  <span class="strong"><strong>printf</strong></span>("---------\n");

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;domains, 0);
  i=0; <span class="strong"><strong>while</strong></span> (1) { 
    <span class="strong"><strong>if</strong></span> (domainsvec[i] == -2) { 
      <span class="strong"><strong>break</strong></span>; 
    } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (domainsvec[i] == -1) {
      <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_push_back" title="2.16.8. igraph_vector_ptr_push_back — Appends an element to the back of a pointer vector.">igraph_vector_ptr_push_back</a></strong></span>(&amp;domains, v);
      v=0;
    } <span class="strong"><strong>else</strong></span> {
      <span class="strong"><strong>if</strong></span> (!v) { 
	v=(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *) <span class="strong"><strong>malloc</strong></span>(<span class="strong"><strong>sizeof</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
	<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(v, 0);
      }
      <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(v, domainsvec[i]);
    }
    i++;
  }

  <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, &amp;domains, &amp;iso, &amp;map, &amp;maps,
			   <span class="emphasis"><em>/*induced=*/</em></span> 0, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);
  
  <span class="strong"><strong>if</strong></span> (!iso) { <span class="strong"><strong>return</strong></span> 3; }
  <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
  n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
    <span class="strong"><strong>igraph_vector_print</strong></span>(v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="1. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
  }

  n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;domains);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(domains)[i];
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong>free</strong></span>(v);
  }
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;domains);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;map);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;maps);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;target);
  
  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231944291888"></a>5. Functions for graphs with 3 or 4 vertices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_34">5.1. <code class="function">igraph_isomorphic_34</code> — Graph isomorphism for 3-4 vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass">5.2. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of a graph with 3 or 4 vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_subgraph">5.3. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_create">5.4. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_34"></a>5.1. <code class="function">igraph_isomorphic_34</code> — Graph isomorphism for 3-4 vertices</h3></div></div></div>
<a class="indexterm" name="idm231944290032"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_34(const igraph_t *graph1, const igraph_t *graph2, 
			 igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



This function uses precomputed indices to decide isomorphism
problems for graphs with only 3 or 4 vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph. Must have the same
  directedness as <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass"></a>5.2. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of a graph with 3 or 4 vertices</h3></div></div></div>
<a class="indexterm" name="idm231951636672"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass(const igraph_t *graph, igraph_integer_t *isoclass);
</pre></div>
<p>
</p>
<p>



</p>
<p>
All graphs with a given number of vertices belong to a number of
isomorphism classes, with every graph in a given class being
isomorphic to each other.

</p>
<p>
This function gives the isomorphism class (a number) of a
graph. Two graphs have the same isomorphism class if and only if
they are isomorphic.

</p>
<p>
The first isomorphism class is numbered zero and it is the empty
graph, the last isomorphism class is the full graph. The number of
isomorphism class for directed graphs with three vertices is 16
(between 0 and 15), for undirected graph it is only 4. For graphs
with four vertices it is 218 (directed) and 11 (undirected).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the isomorphism class will
       be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.2. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>, <a class="link" href="igraph-Motifs.html#igraph_motifs_randesu" title="3.1. igraph_motifs_randesu — Count the number of motifs in a graph"><code class="function">igraph_motifs_randesu()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Because of some limitations this function works only for graphs
with three of four vertices.

</p>
<p>
Time complexity: O(|E|), the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_subgraph"></a>5.3. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</h3></div></div></div>
<a class="indexterm" name="idm231951363808"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass_subgraph(const igraph_t *graph, igraph_vector_t *vids,
			     igraph_integer_t *isoclass);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is only implemented for subgraphs with three or four
vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  A vector containing the vertex ids to be considered as
       a subgraph. Each vertex id should be included at most once.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, this will be set to the
       isomorphism class.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.2. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((d+n)*n), d is the average degree in the network,
and n is the number of vertices in <code class="constant">vids</code>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_create"></a>5.4. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</h3></div></div></div>
<a class="indexterm" name="idm231951191808"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass_create(igraph_t *graph, igraph_integer_t size,
			   igraph_integer_t number, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is implemented only for graphs with three or four
vertices. 
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of vertices to add to the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>number</code></em>:</span></p></td>
<td><p>
  The isomorphism class.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create a directed
       graph. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>, 
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.2. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges in the graph to create.
 
</p>
</div>
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">
      _uacct = "UA-1392972-1";
      urchinTracker();
    </script><table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Cliques.html"><b>← Chapter 15. Cliques and Independent Vertex Sets</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Motifs.html"><b>Chapter 17. Graph Motifs, Dyad Census and Triad Census →</b></a></td>
</tr></table>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container">
      <div class="row">
        <div class="col-xs-12">
          <p class="text-muted credit">
	    &copy; 2003 &ndash; 2020 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
            <!-- &bull; <a href="">Download old releases</a> -->
            <!-- &bull; <a href="">Old documentation</a> -->
            <!-- &bull; <a href="">Authors</a> -->
            <!-- &bull; <a href="">Tools</a> -->
            <!-- &bull; <a href="">Papers citing igraph</a> -->
          </p>
        </div>
      </div>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-2.0.3.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/affix.js"></script>
    <script src="/js/tooltips.js"></script>
    <script src="/js/toggle.js"></script>

    
  </body>
</html>
