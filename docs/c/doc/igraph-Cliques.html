









<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="/img/igraph4.png" type="image/x-icon" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/manual.css" rel="stylesheet">
  </head>

  <body class="cc">
  <div id="wrap">

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle"
                  data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">
            <img src="/img/igraph4.svg" width=35> igraph
          </a>
        </div>
        <div class="navbar-collapse collapse">
	  
	  <ul class="nav navbar-nav">
	    <li><a href="/c">| igraph library</a></li>
	  </ul>
	  
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown"
		 role="button" aria-expanded="false">Products
		<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
		<li>
		  <a href="/r"><i class="icon-fixed-width icon-rlogo"></i>
		    igraph R package</a></li>
		<li>
		  <a href="/python"><i class="icon-fixed-width icon-python"></i>
		    python-igraph</a></li>
		<li>
		  <a href="http://szhorvat.net/mathematica/IGraphM"><i class="icon-fixed-width icon-python"></i>
		    IGraph/M</a></li>
		<li>
		  <a href="/c"><i class="icon-fixed-width icon-c"></i>
		    igraph C library</a></li>
		<li class="divider"></li>
		<li>
		  <a href="https://github.com/igraph/igraphdata">
		    <i class="icon-fixed-width icon-rlogo"></i>
		    igraphdata R package <i class="fa fa-github"></i></a></li>
              </ul>
            </li>
            <li>
              <a href="/news.html"><i class="icon-rss"></i>
		News</a></li>
	    <li><a href="https://github.com/igraph">
	      <i class="icon-github"></i> On github</a></li>
          </ul>
          <!-- <form class="navbar-form navbar-right"> -->
          <!--   <div class="form-group"> -->
          <!--     <input type="text" placeholder="Search docs" -->
	  <!-- 	     class="form-control" size="15"> -->
          <!--   </div> -->
          <!--   <button type="submit" class="btn btn-success"> -->
          <!--     <span class="glyphicon glyphicon-search"></span></button> -->
          <!-- </form> -->
        </div><!--/.navbar-collapse -->
      </div>
    </div>
    
    
    
    <div class="bs-header-outer"><div class="bs-header">
      <div class="container">
        <h1>igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>        
      </div>
    </div></div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-9 col-md-offset-1">
  <div class="bs-docs-section">

    
<div class="navigation-header" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-default" href="igraph-Visitors.html"><i class="icon-chevron-left"></i></a><a accesskey="h" class="btn btn-default" href="index.html"><i class="icon-home"></i></a><a accesskey="n" class="btn btn-default" href="igraph-Isomorphism.html"><i class="icon-chevron-right"></i></a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Cliques"></a>Chapter 15. Cliques and Independent Vertex Sets</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Cliques.html#idm231928861680">1. Cliques</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#idm231928492752">2. Independent Vertex Sets</a></span></dt>
</dl></div>
<p>
These functions calculate various graph properties related
to cliques and independent vertex sets.
</p>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231928861680"></a>1. Cliques</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Cliques.html#igraph_cliques">1.1. <code class="function">igraph_cliques</code> —  Find all or some cliques in a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_largest_cliques">1.2. <code class="function">igraph_largest_cliques</code> —  Finds the largest clique(s) in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_maximal_cliques">1.3. <code class="function">igraph_maximal_cliques</code> —  Find all maximal cliques of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_maximal_cliques_count">1.4. <code class="function">igraph_maximal_cliques_count</code> — Count the number of maximal cliques in a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_clique_number">1.5. <code class="function">igraph_clique_number</code> —  Find the clique number of the graph</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cliques"></a>1.1. <code class="function">igraph_cliques</code> —  Find all or some cliques in a graph</h3></div></div></div>
<a class="indexterm" name="idm231923168896"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_cliques(const igraph_t *graph, igraph_vector_ptr_t *res,
                   igraph_integer_t min_size, igraph_integer_t max_size);
</pre></div>
<p>
</p>
<p>



</p>
<p>
Cliques are fully connected subgraphs of a graph.

</p>
<p>
If you are only interested in the size of the largest clique in the graph,
use <a class="link" href="igraph-Cliques.html#igraph_clique_number" title="1.5. igraph_clique_number — Find the clique number of the graph"><code class="function">igraph_clique_number()</code></a> instead.

</p>
<p>The current implementation of this function searches
for maximal independent vertex sets (see <a class="link" href="igraph-Cliques.html#igraph_maximal_independent_vertex_sets" title="2.3. igraph_maximal_independent_vertex_sets — Find all maximal independent vertex sets of a graph"><code class="function">igraph_maximal_independent_vertex_sets()</code></a>) in the complementer graph
using the algorithm published in: 
S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
for generating all the maximal independent sets. SIAM J Computing,
6:505--517, 1977.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <code class="constant">res</code> will contain pointers to <code class="constant">igraph_vector_t</code>
  objects which contain the indices of vertices involved in a clique.
  The pointer vector will be resized if needed but note that the
  objects in the pointer vector will not be freed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min_size</code></em>:</span></p></td>
<td><p>
  Integer giving the minimum size of the cliques to be
  returned. If negative or zero, no lower bound will be used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max_size</code></em>:</span></p></td>
<td><p>
  Integer giving the maximum size of the cliques to be
  returned. If negative or zero, no upper bound will be used.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_largest_cliques" title="1.2. igraph_largest_cliques — Finds the largest clique(s) in a graph."><code class="function">igraph_largest_cliques()</code></a> and <a class="link" href="igraph-Cliques.html#igraph_clique_number" title="1.5. igraph_clique_number — Find the clique number of the graph"><code class="function">igraph_clique_number()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231928135920"></a><p class="title"><b>Example 15.1.  File <code class="code">examples/simple/igraph_cliques.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
  long int i, n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
  }
  <span class="strong"><strong>printf</strong></span>("\n");
}

void <span class="strong"><strong>warning_handler_ignore</strong></span>(<span class="strong"><strong>const</strong></span> char* reason,<span class="strong"><strong>const</strong></span> char* file,int line,int e) {
}

int <span class="strong"><strong>main</strong></span>() {
  
  igraph_t g;
  igraph_vector_ptr_t result;
  igraph_es_t es;
  igraph_integer_t omega;
  long int i, j, n;
  <span class="strong"><strong>const</strong></span> int params[] = {4, -1, 2, 2, 0, 0, -1, -1};
 
  <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_warning_handler" title="4.2. igraph_set_warning_handler — Install a warning handler">igraph_set_warning_handler</a></strong></span>(warning_handler_ignore);

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;result, 0);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;g, 6, 0, 0);
  <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_es_pairs_small" title="6.9. igraph_es_pairs_small — Edge selector, multiple edges defined by their endpoints as arguments.">igraph_es_pairs_small</a></strong></span>(&amp;es, 0, 0, 1, 0, 2, 3, 5, -1);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, es);
  <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_es_destroy" title="8.2. igraph_es_destroy — Destroys an edge selector object.">igraph_es_destroy</a></strong></span>(&amp;es);
  
  <span class="strong"><strong>for</strong></span> (j=0; j&lt;<span class="strong"><strong>sizeof</strong></span>(params)/(2*<span class="strong"><strong>sizeof</strong></span>(params[0])); j++) {
    <span class="strong"><strong>if</strong></span> (params[2*j+1] != 0) {
      <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_cliques" title="1.1. igraph_cliques — Find all or some cliques in a graph">igraph_cliques</a></strong></span>(&amp;g, &amp;result, params[2*j], params[2*j+1]);  
    } <span class="strong"><strong>else</strong></span> {
      <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_largest_cliques" title="1.2. igraph_largest_cliques — Finds the largest clique(s) in a graph.">igraph_largest_cliques</a></strong></span>(&amp;g, &amp;result);
    }
    n = <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result);
    <span class="strong"><strong>printf</strong></span>("%ld cliques found\n", (long)n);
    <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
      <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v;
      v=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_e" title="2.16.9. igraph_vector_ptr_e — Access an element of a pointer vector.">igraph_vector_ptr_e</a></strong></span>(&amp;result,i);
      <span class="strong"><strong>print_vector</strong></span>((<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)v);
      <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
      <span class="strong"><strong>free</strong></span>(v);
    }
  }
   
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_clique_number" title="1.5. igraph_clique_number — Find the clique number of the graph">igraph_clique_number</a></strong></span>(&amp;g, &amp;omega);
  <span class="strong"><strong>printf</strong></span>("omega=%ld\n", (long)omega);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 5, 2, IGRAPH_TREE_OUT);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_cliques" title="1.1. igraph_cliques — Find all or some cliques in a graph">igraph_cliques</a></strong></span>(&amp;g, &amp;result, 5, 5);
  <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result) != 0) <span class="strong"><strong>return</strong></span> 1;

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;result);

  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_largest_cliques"></a>1.2. <code class="function">igraph_largest_cliques</code> —  Finds the largest clique(s) in a graph.</h3></div></div></div>
<a class="indexterm" name="idm231927878288"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_largest_cliques(const igraph_t *graph, igraph_vector_ptr_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A clique is largest (quite intuitively) if there is no other clique
in the graph which contains more vertices. 

</p>
<p>
Note that this is not necessarily the same as a maximal clique,
ie. the largest cliques are always maximal but a maximal clique is
not always largest.

</p>
<p>The current implementation of this function searches
for maximal cliques using <a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph"><code class="function">igraph_maximal_cliques()</code></a> and drops
those that are not the largest.

</p>
<p>The implementation of this function changed between
igraph 0.5 and 0.6, so the order of the cliques and the order of
vertices within the cliques will almost surely be different between
these two versions.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized pointer vector, the result
       will be stored here. It will be resized as needed. Note that
       vertices of a clique may be returned in arbitrary order.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_cliques" title="1.1. igraph_cliques — Find all or some cliques in a graph"><code class="function">igraph_cliques()</code></a>, <a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph"><code class="function">igraph_maximal_cliques()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(3^(|V|/3)) worst case.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximal_cliques"></a>1.3. <code class="function">igraph_maximal_cliques</code> —  Find all maximal cliques of a graph</h3></div></div></div>
<a class="indexterm" name="idm231927860928"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maximal_cliques(const igraph_t *graph, 
			   igraph_vector_ptr_t *res,
			   igraph_integer_t min_size, 
			   igraph_integer_t max_size);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A maximal clique is a clique which can't be extended any more by
adding a new vertex to it.

</p>
<p>
If you are only interested in the size of the largest clique in the
graph, use <a class="link" href="igraph-Cliques.html#igraph_clique_number" title="1.5. igraph_clique_number — Find the clique number of the graph"><code class="function">igraph_clique_number()</code></a> instead.

</p>
<p>
The current implementation uses a modified Bron-Kerbosch
algorithm to find the maximal cliques, see: David Eppstein,
Maarten Löffler, Darren Strash: Listing All Maximal Cliques in
Sparse Graphs in Near-Optimal Time. Algorithms and Computation,
Lecture Notes in Computer Science Volume 6506, 2010, pp 403-414.

</p>
<p>The implementation of this function changed between
igraph 0.5 and 0.6 and also between 0.6 and 0.7, so the order of
the cliques and the order of vertices within the cliques will
almost surely be different between these three versions.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <code class="constant">res</code> will contain pointers to <code class="constant">igraph_vector_t</code>
  objects which contain the indices of vertices involved in a clique.
  The pointer vector will be resized if needed but note that the
  objects in the pointer vector will not be freed. Note that vertices
  of a clique may be returned in arbitrary order.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min_size</code></em>:</span></p></td>
<td><p>
  Integer giving the minimum size of the cliques to be
  returned. If negative or zero, no lower bound will be used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max_size</code></em>:</span></p></td>
<td><p>
  Integer giving the maximum size of the cliques to be
  returned. If negative or zero, no upper bound will be used.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_maximal_independent_vertex_sets" title="2.3. igraph_maximal_independent_vertex_sets — Find all maximal independent vertex sets of a graph"><code class="function">igraph_maximal_independent_vertex_sets()</code></a>, <a class="link" href="igraph-Cliques.html#igraph_clique_number" title="1.5. igraph_clique_number — Find the clique number of the graph"><code class="function">igraph_clique_number()</code></a> 
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(d(n-d)3^(d/3)) worst case, d is the degeneracy
of the graph, this is typically small for sparse graphs.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231928762496"></a><p class="title"><b>Example 15.2.  File <code class="code">examples/simple/igraph_maximal_cliques.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> NODES 1000
<span class="strong"><strong>#define</strong></span> CLIQUE_SIZE 10
<span class="strong"><strong>#define</strong></span> NO_CLIQUES 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>INT</strong></span>(a) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, (a)))

int <span class="strong"><strong>permutation</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec) {
  int i, r, tmp;
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;CLIQUE_SIZE; i++) {
    r=<span class="strong"><strong>INT</strong></span>(NODES-1);
    tmp=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[i];
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[i]=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[r];
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[r]=tmp;
  }
  <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>sort_cmp</strong></span>(<span class="strong"><strong>const</strong></span> void *a, <span class="strong"><strong>const</strong></span> void *b) {
  <span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **da = (<span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **) a;
  <span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **db = (<span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **) b;
  int i, alen=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(*da), blen=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(*db);
  <span class="strong"><strong>if</strong></span> (alen != blen) { <span class="strong"><strong>return</strong></span> (alen &lt; blen) - (alen &gt; blen); }
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;alen; i++) {
    int ea=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(**da)[i], eb=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(**db)[i];
    <span class="strong"><strong>if</strong></span> (ea != eb) { <span class="strong"><strong>return</strong></span> (ea &gt; eb) - (ea &lt; eb); }
  }
  <span class="strong"><strong>return</strong></span> 0;
}

void <span class="strong"><strong>sort_cliques</strong></span>(igraph_vector_ptr_t *cliques) {
  int i, n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(cliques);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques)[i];
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_sort" title="2.14.1. igraph_vector_sort — Sorts the elements of the vector into ascending order.">igraph_vector_sort</a></strong></span>(v);
  }
  <span class="strong"><strong>igraph_qsort</strong></span>(<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques), (size_t) n,
	       <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *), sort_cmp);
}

void <span class="strong"><strong>print_and_destroy_cliques</strong></span>(igraph_vector_ptr_t *cliques) {
  int i;
  <span class="strong"><strong>sort_cliques</strong></span>(cliques);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(cliques); i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques)[i];
    <span class="strong"><strong>igraph_vector_print</strong></span>(v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="1. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
  }
}

int <span class="strong"><strong>main</strong></span>() {
  
  igraph_t g, g2, cli;
  <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> perm;
  igraph_vector_ptr_t cliques;
  igraph_integer_t no;
  int i;

  <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);
  
  <span class="emphasis"><em>/* Create a graph that has a random component, plus a number of </em></span>
<span class="emphasis"><em>     relatively small cliques */</em></span>
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, NODES-1);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdos-Renyi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;g, IGRAPH_ERDOS_RENYI_GNM, NODES, NODES, 
        <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*loops=*/</em></span> 0);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;cli, CLIQUE_SIZE, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*loops=*/</em></span> 0);

  <span class="strong"><strong>for</strong></span> (i=0; i&lt;NO_CLIQUES; i++) {
    <span class="emphasis"><em>/* Permute vertices of g */</em></span>
    <span class="strong"><strong>permutation</strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="1.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;g, &amp;g2, &amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    g=g2;
    
    <span class="emphasis"><em>/* Add a clique */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_union" title="1.3. igraph_union — Calculates the union of two graphs.">igraph_union</a></strong></span>(&amp;g2, &amp;g, &amp;cli, <span class="emphasis"><em>/*edge_map1=*/</em></span> 0, <span class="emphasis"><em>/*edge_map2=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    g=g2;
  }
  <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_simplify" title="14.6. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;g, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loop=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;cli);
  
  <span class="emphasis"><em>/* Find the maximal cliques */</em></span>
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cliques, 0);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph">igraph_maximal_cliques</a></strong></span>(&amp;g, &amp;cliques, <span class="emphasis"><em>/*min_size=*/</em></span> 3,
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques_count" title="1.4. igraph_maximal_cliques_count — Count the number of maximal cliques in a graph">igraph_maximal_cliques_count</a></strong></span>(&amp;g, &amp;no, <span class="emphasis"><em>/*min_size=*/</em></span> 3, 
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);

  <span class="strong"><strong>if</strong></span> (no != <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;cliques)) { <span class="strong"><strong>return</strong></span> 1; }
  
  <span class="emphasis"><em>/* Print and destroy them */</em></span>

  <span class="strong"><strong>print_and_destroy_cliques</strong></span>(&amp;cliques);
  
  <span class="emphasis"><em>/* Clean up */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;cliques);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="emphasis"><em>/* Build a triangle with a loop (thanks to Emmanuel Navarro) */</em></span>

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 3, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, 0, 0, -1);

  <span class="emphasis"><em>/* Find the maximal cliques */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cliques, 0);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph">igraph_maximal_cliques</a></strong></span>(&amp;g, &amp;cliques, <span class="emphasis"><em>/*min_size=*/</em></span> 3,
    <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques_count" title="1.4. igraph_maximal_cliques_count — Count the number of maximal cliques in a graph">igraph_maximal_cliques_count</a></strong></span>(&amp;g, &amp;no, <span class="emphasis"><em>/*min_size=*/</em></span> 3, 
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);

  <span class="strong"><strong>if</strong></span> (no != <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;cliques)) { <span class="strong"><strong>return</strong></span> 2; }

  <span class="emphasis"><em>/* Print and destroy them */</em></span>

  <span class="strong"><strong>print_and_destroy_cliques</strong></span>(&amp;cliques);
  
  <span class="emphasis"><em>/* Clean up */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;cliques);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximal_cliques_count"></a>1.4. <code class="function">igraph_maximal_cliques_count</code> — Count the number of maximal cliques in a graph</h3></div></div></div>
<a class="indexterm" name="idm231928621552"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maximal_cliques_count(const igraph_t *graph,
				 igraph_integer_t *res,
				 igraph_integer_t min_size,
				 igraph_integer_t max_size);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The current implementation uses a modified Bron-Kerbosch
algorithm to find the maximal cliques, see: David Eppstein,
Maarten Löffler, Darren Strash: Listing All Maximal Cliques in
Sparse Graphs in Near-Optimal Time. Algorithms and Computation,
Lecture Notes in Computer Science Volume 6506, 2010, pp 403-414.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <code class="constant">res</code> will contain pointers to <code class="constant">igraph_vector_t</code>
  objects which contain the indices of vertices involved in a clique.
  The pointer vector will be resized if needed but note that the
  objects in the pointer vector will not be freed. Note that vertices
  of a clique may be returned in arbitrary order.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min_size</code></em>:</span></p></td>
<td><p>
  Integer giving the minimum size of the cliques to be
  returned. If negative or zero, no lower bound will be used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max_size</code></em>:</span></p></td>
<td><p>
  Integer giving the maximum size of the cliques to be
  returned. If negative or zero, no upper bound will be used.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph"><code class="function">igraph_maximal_cliques()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(d(n-d)3^(d/3)) worst case, d is the degeneracy
of the graph, this is typically small for sparse graphs.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231928604176"></a><p class="title"><b>Example 15.3.  File <code class="code">examples/simple/igraph_maximal_cliques.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> NODES 1000
<span class="strong"><strong>#define</strong></span> CLIQUE_SIZE 10
<span class="strong"><strong>#define</strong></span> NO_CLIQUES 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>INT</strong></span>(a) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, (a)))

int <span class="strong"><strong>permutation</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec) {
  int i, r, tmp;
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;CLIQUE_SIZE; i++) {
    r=<span class="strong"><strong>INT</strong></span>(NODES-1);
    tmp=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[i];
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[i]=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[r];
    <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[r]=tmp;
  }
  <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>sort_cmp</strong></span>(<span class="strong"><strong>const</strong></span> void *a, <span class="strong"><strong>const</strong></span> void *b) {
  <span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **da = (<span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **) a;
  <span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **db = (<span class="strong"><strong>const</strong></span> <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> **) b;
  int i, alen=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(*da), blen=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(*db);
  <span class="strong"><strong>if</strong></span> (alen != blen) { <span class="strong"><strong>return</strong></span> (alen &lt; blen) - (alen &gt; blen); }
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;alen; i++) {
    int ea=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(**da)[i], eb=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(**db)[i];
    <span class="strong"><strong>if</strong></span> (ea != eb) { <span class="strong"><strong>return</strong></span> (ea &gt; eb) - (ea &lt; eb); }
  }
  <span class="strong"><strong>return</strong></span> 0;
}

void <span class="strong"><strong>sort_cliques</strong></span>(igraph_vector_ptr_t *cliques) {
  int i, n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(cliques);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques)[i];
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_sort" title="2.14.1. igraph_vector_sort — Sorts the elements of the vector into ascending order.">igraph_vector_sort</a></strong></span>(v);
  }
  <span class="strong"><strong>igraph_qsort</strong></span>(<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques), (size_t) n,
	       <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *), sort_cmp);
}

void <span class="strong"><strong>print_and_destroy_cliques</strong></span>(igraph_vector_ptr_t *cliques) {
  int i;
  <span class="strong"><strong>sort_cliques</strong></span>(cliques);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(cliques); i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v=<span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cliques)[i];
    <span class="strong"><strong>igraph_vector_print</strong></span>(v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="1. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
  }
}

int <span class="strong"><strong>main</strong></span>() {
  
  igraph_t g, g2, cli;
  <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> perm;
  igraph_vector_ptr_t cliques;
  igraph_integer_t no;
  int i;

  <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);
  
  <span class="emphasis"><em>/* Create a graph that has a random component, plus a number of </em></span>
<span class="emphasis"><em>     relatively small cliques */</em></span>
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, NODES-1);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdos-Renyi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;g, IGRAPH_ERDOS_RENYI_GNM, NODES, NODES, 
        <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*loops=*/</em></span> 0);
  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;cli, CLIQUE_SIZE, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*loops=*/</em></span> 0);

  <span class="strong"><strong>for</strong></span> (i=0; i&lt;NO_CLIQUES; i++) {
    <span class="emphasis"><em>/* Permute vertices of g */</em></span>
    <span class="strong"><strong>permutation</strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="1.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;g, &amp;g2, &amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    g=g2;
    
    <span class="emphasis"><em>/* Add a clique */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_union" title="1.3. igraph_union — Calculates the union of two graphs.">igraph_union</a></strong></span>(&amp;g2, &amp;g, &amp;cli, <span class="emphasis"><em>/*edge_map1=*/</em></span> 0, <span class="emphasis"><em>/*edge_map2=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    g=g2;
  }
  <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_simplify" title="14.6. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;g, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loop=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;cli);
  
  <span class="emphasis"><em>/* Find the maximal cliques */</em></span>
  
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cliques, 0);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph">igraph_maximal_cliques</a></strong></span>(&amp;g, &amp;cliques, <span class="emphasis"><em>/*min_size=*/</em></span> 3,
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques_count" title="1.4. igraph_maximal_cliques_count — Count the number of maximal cliques in a graph">igraph_maximal_cliques_count</a></strong></span>(&amp;g, &amp;no, <span class="emphasis"><em>/*min_size=*/</em></span> 3, 
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);

  <span class="strong"><strong>if</strong></span> (no != <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;cliques)) { <span class="strong"><strong>return</strong></span> 1; }
  
  <span class="emphasis"><em>/* Print and destroy them */</em></span>

  <span class="strong"><strong>print_and_destroy_cliques</strong></span>(&amp;cliques);
  
  <span class="emphasis"><em>/* Clean up */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;cliques);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="emphasis"><em>/* Build a triangle with a loop (thanks to Emmanuel Navarro) */</em></span>

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 3, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, 0, 0, -1);

  <span class="emphasis"><em>/* Find the maximal cliques */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cliques, 0);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph">igraph_maximal_cliques</a></strong></span>(&amp;g, &amp;cliques, <span class="emphasis"><em>/*min_size=*/</em></span> 3,
    <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques_count" title="1.4. igraph_maximal_cliques_count — Count the number of maximal cliques in a graph">igraph_maximal_cliques_count</a></strong></span>(&amp;g, &amp;no, <span class="emphasis"><em>/*min_size=*/</em></span> 3, 
       <span class="emphasis"><em>/*max_size=*/</em></span> 0 <span class="emphasis"><em>/*no limit*/</em></span>);

  <span class="strong"><strong>if</strong></span> (no != <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;cliques)) { <span class="strong"><strong>return</strong></span> 2; }

  <span class="emphasis"><em>/* Print and destroy them */</em></span>

  <span class="strong"><strong>print_and_destroy_cliques</strong></span>(&amp;cliques);
  
  <span class="emphasis"><em>/* Clean up */</em></span>

  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;cliques);
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_clique_number"></a>1.5. <code class="function">igraph_clique_number</code> —  Find the clique number of the graph</h3></div></div></div>
<a class="indexterm" name="idm231928507024"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_clique_number(const igraph_t *graph, igraph_integer_t *no);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The clique number of a graph is the size of the largest clique.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The clique number will be returned to the <code class="constant">igraph_integer_t</code>
  pointed by this variable.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_cliques" title="1.1. igraph_cliques — Find all or some cliques in a graph"><code class="function">igraph_cliques()</code></a>, <a class="link" href="igraph-Cliques.html#igraph_largest_cliques" title="1.2. igraph_largest_cliques — Finds the largest clique(s) in a graph."><code class="function">igraph_largest_cliques()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(3^(|V|/3)) worst case.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm231928492752"></a>2. Independent Vertex Sets</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Cliques.html#igraph_independent_vertex_sets">2.1. <code class="function">igraph_independent_vertex_sets</code> —  Find all independent vertex sets in a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_largest_independent_vertex_sets">2.2. <code class="function">igraph_largest_independent_vertex_sets</code> —  Finds the largest independent vertex set(s) in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_maximal_independent_vertex_sets">2.3. <code class="function">igraph_maximal_independent_vertex_sets</code> —  Find all maximal independent vertex sets of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Cliques.html#igraph_independence_number">2.4. <code class="function">igraph_independence_number</code> —  Find the independence number of the graph</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_independent_vertex_sets"></a>2.1. <code class="function">igraph_independent_vertex_sets</code> —  Find all independent vertex sets in a graph</h3></div></div></div>
<a class="indexterm" name="idm231928490832"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_independent_vertex_sets(const igraph_t *graph,
				   igraph_vector_ptr_t *res,
				   igraph_integer_t min_size,
				   igraph_integer_t max_size);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A vertex set is considered independent if there are no edges between
them.

</p>
<p>
If you are interested in the size of the largest independent vertex set,
use <a class="link" href="igraph-Cliques.html#igraph_independence_number" title="2.4. igraph_independence_number — Find the independence number of the graph"><code class="function">igraph_independence_number()</code></a> instead.

</p>
<p>
The current implementation was ported to igraph from the Very Nauty Graph
Library by Keith Briggs and uses the algorithm from the paper
S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
for generating all the maximal independent sets. SIAM J Computing,
6:505--517, 1977.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <code class="constant">res</code> will contain pointers to <code class="constant">igraph_vector_t</code>
  objects which contain the indices of vertices involved in an independent
  vertex set. The pointer vector will be resized if needed but note that the
  objects in the pointer vector will not be freed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min_size</code></em>:</span></p></td>
<td><p>
  Integer giving the minimum size of the sets to be
  returned. If negative or zero, no lower bound will be used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max_size</code></em>:</span></p></td>
<td><p>
  Integer giving the maximum size of the sets to be
  returned. If negative or zero, no upper bound will be used. 
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_largest_independent_vertex_sets" title="2.2. igraph_largest_independent_vertex_sets — Finds the largest independent vertex set(s) in a graph."><code class="function">igraph_largest_independent_vertex_sets()</code></a>, 
<a class="link" href="igraph-Cliques.html#igraph_independence_number" title="2.4. igraph_independence_number — Find the independence number of the graph"><code class="function">igraph_independence_number()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm231928471056"></a><p class="title"><b>Example 15.4.  File <code class="code">examples/simple/igraph_independent_sets.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* </em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>
<span class="emphasis"><em>   </em></span>
<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA </em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
  long int i, n=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="ch07.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
  }
  <span class="strong"><strong>printf</strong></span>("\n");
}

void <span class="strong"><strong>warning_handler_ignore</strong></span>(<span class="strong"><strong>const</strong></span> char* reason,<span class="strong"><strong>const</strong></span> char* file,int line,int e) {
}

int <span class="strong"><strong>main</strong></span>() {
  
  igraph_t g;
  igraph_vector_ptr_t result;
  long int i, j, n;
  igraph_integer_t alpha;
  <span class="strong"><strong>const</strong></span> int params[] = {4, -1, 2, 2, 0, 0, -1, -1};
  
  <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_warning_handler" title="4.2. igraph_set_warning_handler — Install a warning handler">igraph_set_warning_handler</a></strong></span>(warning_handler_ignore);
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;result, 0);

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 5, 2, IGRAPH_TREE_OUT);
  <span class="strong"><strong>for</strong></span> (j=0; j&lt;<span class="strong"><strong>sizeof</strong></span>(params)/(2*<span class="strong"><strong>sizeof</strong></span>(params[0])); j++) {
    <span class="strong"><strong>if</strong></span> (params[2*j+1] != 0) {
      <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_independent_vertex_sets" title="2.1. igraph_independent_vertex_sets — Find all independent vertex sets in a graph">igraph_independent_vertex_sets</a></strong></span>(&amp;g, &amp;result, params[2*j], params[2*j+1]);
    } <span class="strong"><strong>else</strong></span> {
      <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_largest_independent_vertex_sets" title="2.2. igraph_largest_independent_vertex_sets — Finds the largest independent vertex set(s) in a graph.">igraph_largest_independent_vertex_sets</a></strong></span>(&amp;g, &amp;result);
    }
    n = <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result);
    <span class="strong"><strong>printf</strong></span>("%ld independent sets found\n", (long)n);
    <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
      <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v;
      v=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_e" title="2.16.9. igraph_vector_ptr_e — Access an element of a pointer vector.">igraph_vector_ptr_e</a></strong></span>(&amp;result,i);
      <span class="strong"><strong>print_vector</strong></span>((<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)v);
      <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
      <span class="strong"><strong>free</strong></span>(v);
    }
  }
  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 10, 2, IGRAPH_TREE_OUT);
  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_independent_vertex_sets" title="2.3. igraph_maximal_independent_vertex_sets — Find all maximal independent vertex sets of a graph">igraph_maximal_independent_vertex_sets</a></strong></span>(&amp;g, &amp;result);
  n = <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result);
  <span class="strong"><strong>printf</strong></span>("%ld maximal independent sets found\n", (long)n);
  <span class="strong"><strong>for</strong></span> (i=0; i&lt;n; i++) {
    <a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v;
    v=<span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_e" title="2.16.9. igraph_vector_ptr_e — Access an element of a pointer vector.">igraph_vector_ptr_e</a></strong></span>(&amp;result,i);
    <span class="strong"><strong>print_vector</strong></span>((<a class="link" href="ch07.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)v);
    <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
    <span class="strong"><strong>free</strong></span>(v);
  }
  <span class="strong"><strong><a class="link" href="ch07.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;result);

  <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_independence_number" title="2.4. igraph_independence_number — Find the independence number of the graph">igraph_independence_number</a></strong></span>(&amp;g, &amp;alpha);
  <span class="strong"><strong>printf</strong></span>("alpha=%ld\n", (long)alpha);

  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

  <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_largest_independent_vertex_sets"></a>2.2. <code class="function">igraph_largest_independent_vertex_sets</code> —  Finds the largest independent vertex set(s) in a graph.</h3></div></div></div>
<a class="indexterm" name="idm231932186416"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_largest_independent_vertex_sets(const igraph_t *graph,
					   igraph_vector_ptr_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
An independent vertex set is largest if there is no other
independent vertex set with more vertices in the graph.

</p>
<p>
The current implementation was ported to igraph from the Very Nauty Graph
Library by Keith Briggs and uses the algorithm from the paper
S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
for generating all the maximal independent sets. SIAM J Computing,
6:505--517, 1977.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
    here. It will be resized as needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_independent_vertex_sets" title="2.1. igraph_independent_vertex_sets — Find all independent vertex sets in a graph"><code class="function">igraph_independent_vertex_sets()</code></a>, <a class="link" href="igraph-Cliques.html#igraph_maximal_independent_vertex_sets" title="2.3. igraph_maximal_independent_vertex_sets — Find all maximal independent vertex sets of a graph"><code class="function">igraph_maximal_independent_vertex_sets()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximal_independent_vertex_sets"></a>2.3. <code class="function">igraph_maximal_independent_vertex_sets</code> —  Find all maximal independent vertex sets of a graph</h3></div></div></div>
<a class="indexterm" name="idm231932514272"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maximal_independent_vertex_sets(const igraph_t *graph,
					   igraph_vector_ptr_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A maximal independent vertex set is an independent vertex set which
can't be extended any more by adding a new vertex to it.

</p>
<p>
The algorithm used here is based on the following paper:
S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
generating all the maximal independent sets. SIAM J Computing,
6:505--517, 1977.

</p>
<p>
The implementation was originally written by Kevin O'Neill and modified
by K M Briggs in the Very Nauty Graph Library. I simply re-wrote it to
use igraph's data structures.

</p>
<p>
If you are interested in the size of the largest independent vertex set,
use <a class="link" href="igraph-Cliques.html#igraph_independence_number" title="2.4. igraph_independence_number — Find the independence number of the graph"><code class="function">igraph_independence_number()</code></a> instead.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <code class="constant">res</code> will contain pointers to <code class="constant">igraph_vector_t</code>
  objects which contain the indices of vertices involved in an independent
  vertex set. The pointer vector will be resized if needed but note that the
  objects in the pointer vector will not be freed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.3. igraph_maximal_cliques — Find all maximal cliques of a graph"><code class="function">igraph_maximal_cliques()</code></a>, <a class="link" href="igraph-Cliques.html#igraph_independence_number" title="2.4. igraph_independence_number — Find the independence number of the graph"><code class="function">igraph_independence_number()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_independence_number"></a>2.4. <code class="function">igraph_independence_number</code> —  Find the independence number of the graph</h3></div></div></div>
<a class="indexterm" name="idm231931999568"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_independence_number(const igraph_t *graph, igraph_integer_t *no);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The independence number of a graph is the cardinality of the largest
independent vertex set.

</p>
<p>
The current implementation was ported to igraph from the Very Nauty Graph
Library by Keith Briggs and uses the algorithm from the paper
S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
for generating all the maximal independent sets. SIAM J Computing,
6:505--517, 1977.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The independence number will be returned to the <code class="constant">igraph_integer_t</code> pointed by this variable.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Cliques.html#igraph_independent_vertex_sets" title="2.1. igraph_independent_vertex_sets — Find all independent vertex sets in a graph"><code class="function">igraph_independent_vertex_sets()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
</div>
</div>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script type="text/javascript">
      _uacct = "UA-1392972-1";
      urchinTracker();
    </script><table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Visitors.html"><b>← Chapter 14. Graph visitors</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Isomorphism.html"><b>Chapter 16. Graph Isomorphism →</b></a></td>
</tr></table>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container">
      <div class="row">
        <div class="col-xs-12">
          <p class="text-muted credit">
	    &copy; 2003 &ndash; 2020 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
            <!-- &bull; <a href="">Download old releases</a> -->
            <!-- &bull; <a href="">Old documentation</a> -->
            <!-- &bull; <a href="">Authors</a> -->
            <!-- &bull; <a href="">Tools</a> -->
            <!-- &bull; <a href="">Papers citing igraph</a> -->
          </p>
        </div>
      </div>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-2.0.3.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/affix.js"></script>
    <script src="/js/tooltips.js"></script>
    <script src="/js/toggle.js"></script>

    
  </body>
</html>
